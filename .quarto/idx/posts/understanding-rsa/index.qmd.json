{"title":"Understanding RSA: Number Theory,Primes, Fermat, Euler and such","markdown":{"yaml":{"title":"Understanding RSA: Number Theory,Primes, Fermat, Euler and such","author":"Rodi Düger","date":"2023-08-28","categories":["computer_science"]},"headingText":"What is RSA ?","containsRefs":false,"markdown":"\n\nWhile searching the internet for a somehow in-depth article on the mathematics underpinning RSA encryption, I found myself somewhat dissatisfied with the available resources. This ignited a longstanding aspiration within me to start writing, so here is my debut piece !\n\n------------------------------------------------------------------------\n\n\nRSA, or Rivest-Shamir-Adleman, is a public-key encryption system. It was introduced way back in 1977, making it quite old, but surprisingly, it's still widely used today (although it should not be used anymore[¹](https://blog.trailofbits.com/2019/07/08/fuck-rsa/)) . Now, you might be thinking, \"Why write a blog post about an ‘ancient’ encryption method?\" Well, that's a fair question. The thing is, RSA isn't just a relic – it's got an educational treasure trove. It's a great example of how the difficulty of prime factorization can be turned into a one-way function.\n\nFirst, we'll take a brief look at how RSA generates keys, encrypts, and decrypts data. Then, we'll explore the math behind it, which will help us grasp why RSA was designed the way it is.\n\n------------------------------------------------------------------------\n\n# Key Generation\n\nRSA key generation involves several steps to generate a public and a private key:\n\n-   **Select two large prime numbers:** First, we pick two prime numbers $p$ and $q$, which should be large enough to ensure the security. Note that $p \\neq q$\n-   **Calculate the modulo:** The modulo is denoted as $n$ and it defines the modulo algebraic structure that we operate on\n\n$$\nn = p \\cdot q\n$$\n\n-   **Evaluate Euler’s Phi (totient) function at $n$:** This is an important step but we will discuss the equation below later as we move forward.\n\n$$\n\\phi (n) =  (p-1) \\cdot (q-1)\n$$\n\n-   **Choose a public exponent:** Choose a public exponent $e$, which should satisfy the following condition ($gcd(x,y)$ stands for greatest common divisor of $x$ and $y$ ):\n\n$$\n1<e<\\phi(n) \\; \\land \\; gcd(e, \\phi(n)) = 1\n$$\n\n-   **Calculate the secret exponent:** Calculate the secret exponent d, such that\n\n$$\ne \\cdot d \\equiv 1 \\; mod \\; \\phi(n)\n$$\n\nPublic key $pk$ is $(n,e)$ and secret key $sk$ is $(n,d)$.\n\n------------------------------------------------------------------------\n\n# Encryption and Decryption\n\nOnce the public and private keys are generated, encryption and decryption is pretty simple:\n\n$$\nEnc(pk, m) := c =  m^e \\; mod \\; n\n$$\n\n$$\nDec(sk, c) = c^d \\; mod \\; n\n$$\n\n------------------------------------------------------------------------\n\nYou might be thinking, \"How does this even work? What's the trick?\" Well, the magic happens behind the scenes with a bunch of number theory, and we're all set to dive right into it!\n\nLet's introduce you to the mathematics that will help us grasp why RSA functions as it does.\n\n------------------------------------------------------------------------\n\n# Euler's Totient (Phi) Function\n\nIn number theory, Euler's totient function counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It is written using the Greek letter phi as $ \\phi $, and may also be called Euler's phi function. In other words, it is the number of integers $k$ in the range $1 \\leq k \\leq n$ for which the greatest common divisor $gcd(n, k)$ is equal to $1$.\n\nTo illustrate, consider this example:\n\n$$ \\displaylines{\\textrm{Let } n=6 \\\\ gcd(0,6) = 6 \\;\\; ,\\;\\; gcd(1,6)=1 \\;\\; ,\\;\\; gcd(2,6) = 2 \\\\ gcd (3,6) = 3 \\;\\; ,\\;\\; gcd(4,6) = 2 \\;\\; ,\\;\\; gcd(5,6) = 1} $$\n\nHere, we see that there are only 2 integers, which are relatively prime to 6:\n\n$$\n\\implies \\phi(n) = \\phi(6) = 2\n$$\n\nBut as you can infer from the example, this isn't the most efficient way to calculate Euler's totient function for a given number $n$. There's actually a simpler approach to compute this function for any integer, thanks to the fact that Euler's totient function is a multiplicative function, which means:\n\n$$\n\\displaylines{\\textrm{Let } n= p \\cdot q \\textrm{  and }p \\textrm{ and } q \\textrm{ are coprime} \\\\  \\phi(n)=\\phi(p \\cdot q) = \\phi(p) \\cdot \\phi(q)}\n$$\n\nMultiplicative property of Euler’s totient function is actually not a trivial property. We can prove this property using Chinese Remainder Theorem (CRT).\n\n## Chinese Remainder Theorem\n\nThe Chinese Remainder Theorem (CRT) is a fundamental theorem in number theory that deals with solving systems of simultaneous modular congruences. It provides a way to find a unique solution to a set of congruences when the moduli involved are pairwise coprime (i.e., they have no common factors other than 1). The theorem is named after its historical association with ancient Chinese mathematics.\n\n**Theorem:**\n\nLet $n_1, n_2, ..., n_k$ be pairwise coprime positive integers and let $a_1,a_2,...,a_k$ be any set of integers. Then the system of modular congruences\n\n$$\n\\displaylines{x \\equiv a_1 \\;(mod \\;n_1)\\\\x \\equiv a_2 \\;(mod \\; n_2)\\\\.\\\\.\\\\x \\equiv \\; a_k \\; (mod \\; n_k) }\n$$\n\nhas a **unique** solution in $mod \\; N$, whereas $N:= n_1 \\cdot n_2 \\cdot...\\cdot n_k$\n\nEssentially, what the thorem states is that, the map\n\n$$\nx \\; mod \\; N \\mapsto (x \\; mod \\; n_1,x \\; mod \\; n_2,...,x \\; mod \\; n_k )\n$$\n\ndefines an isomorphism between $\\mathbb{Z}/N\\mathbb{Z}$ and $\\mathbb{Z}/n_1\\mathbb{Z}\\times\\mathbb{Z}/n_2\\mathbb{Z}\\times...\\times\\mathbb{Z}/n_k\\mathbb{Z}$\n\nI'm not going to delve into a formal proof explaining why Euler's totient function acts as a multiplicative function under certain assumptions. However, what's essential to recognize here is that the isomorphism between these two rings leads to the pivotal observation of Euler's totient function possessing a multiplicative property.\n\nThere's another observation we can make about Euler's totient function, and it will come in handy as we proceed:\n\n------------------------------------------------------------------------\n\nLet $p$ be a prime and $k \\geq1$. Then the following equation holds:\n\n$$\n\\phi(p^k) = p^k - p^{k-1}\n$$\n\n**Proof:** Since $p$ is a prime number, the only possible values of $gcd(p^k, m)$ are $1, p, p^2, ..., p^k$, and the only way to have $gcd(p^k, m) > 1$ is if $m$ is a multiple of $p$, that is, $m \\in {p, 2p, 3p, ..., p^{k − 1} \\cdot p = p^k}$, and there are $p^{k − 1}$ such multiples not greater than $p^k$. Therefore, the other $p^k − p^{k − 1}$ numbers are all relatively prime to $p^k$[²](https://en.wikipedia.org/wiki/Euler%27s_totient_function).\n\n**Example:** Let's compute $\\phi(3^2)$:\n\n$$\n\\displaylines{gcd(0,9) = 9 \\;\\; ,\\;\\; gcd(1,9)=1  \\;\\; ,\\;\\;  gcd(2,9) = 1 \\\\ gcd (3,9) = 3  \\;\\; ,\\;\\;  gcd(4,9) = 1 \\;\\; ,\\;\\; gcd(5,9) = 1 \\\\gcd(6,9) = 3 \\;\\; ,\\;\\; gcd(7,9)=1  \\;\\; ,\\;\\;  gcd(8,9) = 1\\\\ \\implies \\phi(3^2) = 6 = 3^2 - 3^1}\n$$\n\n------------------------------------------------------------------------\n\nNow let's take a look at the simpler approach to compute this function for any integer:\n\n------------------------------------------------------------------------\n\nLet $m$ has the following prime factorization:\n\n$$\nm = p_1^{e_1} \\cdot p_2^{e_2}\\cdot...\\cdot p_n^{e_n}\n$$\n\nwhereas $e_i \\in \\mathbb{N}$. With a little assistance from our previous observation, we can assert the following:\n\n$$\n\\phi(m) = \\prod_{i=1}^n\\phi(p_i^{e^i}) = \\prod_{i=1}^n(p_i^{e_i} - p_i^{e_i -1})\n$$\n\n------------------------------------------------------------------------\n\nNow it should be more clear how we computed $\\phi(n)$ as $\\phi(n) = \\phi(p) \\cdot \\phi(q)$ in the key generation section.\n\nPrime factorization of $n$ is $n = p^1 \\cdot q^1$, then:\n\n$$\n\\phi(n) = \\phi(p^1 \\cdot q^1) = \\phi(p^1) \\cdot \\phi(q^1) = (p^1-p^0)\\cdot(q^1-q^0) = (p-1)\\cdot(q-1)\n$$\n\nThis insight should shed light on why we generate prime numbers to generate keys in the first place. It's crucial to emphasize that this computation becomes feasible only when we possess the prime factorization of a given integer $n$. Yet, for a large $n$, it might prove impractical to factorize it into its prime components within a reasonable timeframe. Exactly for this reason, we emphasize that **\"RSA uses the complexity of prime factorization to guarantee its security,\"** as this very characteristic forms the heart of the RSA cryptosystem.\n\nIf we're aware of the prime factors of a specific number $n$, we can efficiently calculate the Euler's totient function $\\phi(n)$, allowing for efficient decryption. However, when we lack knowledge of the prime factors of $n$ efficiently computing $\\phi(n)$ becomes a daunting task. We could resort to a brute-force approach, yet this becomes unfeasible when dealing with significantly large values of $n$, because of the immense time it would demand.\n\n------------------------------------------------------------------------\n\nNow that we've understood some key features of Euler's totient function that are vital for key generation, let's address the question: **\"Why do we even use Euler's totient function?\"**\n\nLet's explore the answer.\n\n# Euler's Theorem\n\nEuler's Theorem is integral to the security and functioning of RSA encryption. The use of modular exponentiation in both encryption and decryption operations leverages Euler's Theorem. Here's how:\n\n------------------------------------------------------------------------\n\n**Euler's Theorem:**\n\nLet $a$ and $m$ be positive coprime integers ($gcd(a,m)=1$), then:\n\n$$\na^{\\phi(m)} \\equiv 1 \\; (mod \\; m)\n$$\n\n**Example:**\n\nLet $m =10$ and $a=3$.\n\nSince $gcd(10,3) = 1$, $a^{\\phi(m)}$ should be equivalent to $1 \\; (mod \\; m)$. Let's check:\n\n$$\n\\phi(m) = \\phi(10) = \\phi(5 \\cdot 2) = (5-1) \\cdot (2-1) = 4\n$$\n\n$$\na^{\\phi(m)} = 3^4 =81 \\equiv 1 \\; (mod \\; 10)\n$$\n\n------------------------------------------------------------------------\n\nUnfortunately, I'm not a mathematician. :/ So, I don't want to explain a proof, which I'm not really familiar with. Let's just accept Euler's theorem as a given truth, which, in fact, it is :D\n\nLet's now look at a special case of Euler's Theorem, which is Fermat's Little Theorem !\n\n------------------------------------------------------------------------\n\n**Fermat's Little Theorem:**\n\nLet $a$ be a positive integer, $p$ be a prime and $gcd(a,p) = 1$. Then:\n\n$$\na^p \\equiv a \\; (mod \\; p)\n$$\n\n$$\n\\iff\n$$\n\n$$\na \\cdot (a^{p-1} -1) \\equiv 0 \\; (mod \\; p)\n$$\n\n$$\n\\iff\n$$\n\n$$\na^{p-1} \\equiv 1 \\; (mod \\; p)\n$$\n\n**Proof**: Fermat's Little Theorem is basically a special case of Euler's theorem, if the modulo is a prime number.\n\nLet $a$ be a positive integer, $p$ be a prime and $gcd(a,p) = 1$.\n\nSince $gcd(a,p)=1$, using Euler's Theorem:\n\n$$\na^{\\phi(p)} \\equiv 1 \\; (mod \\; p)\n$$\n\nWe know that $\\phi(p) = p-1$, if $p$ is a prime.\n\n$$\n\\implies a^{p-1} \\equiv 1 \\; (mod \\; p)\n$$\n\n------------------------------------------------------------------------\n\n# Correctness of RSA\n\nNow, armed with all the necessary tools, we can demonstrate that the $Enc(pk,m)$ and $Dec(sk,c)$ operations within the RSA cryptosystem act as perfect inverses of one another.\n\n------------------------------------------------------------------------\n\n**Lemma(Correctness):** A public key algorithm $(Gen,Enc,Dec)$ is correct if\n\n$$\n\\forall m,pk,sk: (pk,sk) \\leftarrow Gen(1^k) \\implies Dec(sk, Enc(pk,m)) = m\n$$\n\n------------------------------------------------------------------------\n\n**Let's prove the correctness of RSA together, step by step !**\n\nLet $pk=(n,e)$ and $sk=(n,d)$ be a pair of public and secret key generated by RSA key generation algorithm.\n\nSince $Dec(sk, Enc(pk,m)) = (m^e)^d \\; mod \\; n$, what we want to show is, that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; n)\n$$\n\nFirst thing to note here is, that it is enough to check that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; p)\n$$\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; q)\n$$\n\nBecause by the Chinese Remainder Theorem, the map\n\n$$\nm \\; mod \\; n \\mapsto (m \\; mod \\; p,m \\; mod \\; q)\n$$\n\ndefines a ring isomorphism between $\\mathbb{Z}/n\\mathbb{Z}$ and $\\mathbb{Z}/p\\mathbb{Z}\\times\\mathbb{Z}/q\\mathbb{Z}$.\n\nSince $p$ and $q$ are arbitrarily chosen two prime numbers, they don't have variable specific constraints and hence it is enough to prove that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; p)\n$$\n\nThen proof of $(m^e)^d \\equiv m \\; (mod \\; q)$ would be analogue.\n\n$$\n(m^e)^d \\equiv m^{e \\cdot d} \\; (mod \\; p) \\tag{1}\n$$\n\n$$\nm^{e \\cdot d} \\equiv m^{(1 \\; mod \\; \\phi(n))} \\; (mod \\; p) \\tag{2}\n$$\n\n$$\nm^{(1 \\; mod \\; \\phi(n))} \\equiv m^{(k \\cdot \\phi(n) + 1)} \\; (mod \\; p), \\; k \\in \\mathbb{N}_0 \\tag{3}\n$$\n\n$$\nm^{(k \\cdot \\phi(n) + 1)} \\equiv m^{k \\cdot \\phi(n)} \\cdot m \\; (mod \\; p) \\tag{4}\n$$\n\n$$\nm^{k \\cdot \\phi(n)} \\cdot m \\equiv m^{k \\cdot (p-1) \\cdot (q-1)} \\cdot m \\; (mod \\; p) \\tag{5}\n$$\n\n$$\nm^{k \\cdot (p-1) \\cdot (q-1)} \\cdot m \\equiv (m^{p-1})^{k \\cdot (q-1)} \\cdot m \\; (mod \\; p) \\tag{6}\n$$\n\n$$\n(m^{p-1})^{k \\cdot (q-1)} \\cdot m \\equiv 1^{k \\cdot (q-1)} \\cdot m \\; (mod \\; p)\\tag{7}\n$$\n\n$$\n 1^{k \\cdot (q-1)} \\cdot m \\equiv m \\; (mod \\; p) \\tag{8}\n$$\n\n-   Step $(2)$ holds true because in our key generation, we intentionally selected $d$ to serve as the inverse of $e$ in modulo $\\phi(n)$.\n\n-   Step $(5)$ holds true because of properties of Euler's totient function mentioned above. If you can't understand why this step holds true, check the section about Euler's totient function and do not forget that $n = p \\cdot q$ and $p,q$ are prime numbers with $p \\neq q$\n\n-   Step $(7)$ holds true because of Fermat's Little Theorem\n\n------------------------------------------------------------------------","srcMarkdownNoYaml":"\n\nWhile searching the internet for a somehow in-depth article on the mathematics underpinning RSA encryption, I found myself somewhat dissatisfied with the available resources. This ignited a longstanding aspiration within me to start writing, so here is my debut piece !\n\n------------------------------------------------------------------------\n\n# What is RSA ?\n\nRSA, or Rivest-Shamir-Adleman, is a public-key encryption system. It was introduced way back in 1977, making it quite old, but surprisingly, it's still widely used today (although it should not be used anymore[¹](https://blog.trailofbits.com/2019/07/08/fuck-rsa/)) . Now, you might be thinking, \"Why write a blog post about an ‘ancient’ encryption method?\" Well, that's a fair question. The thing is, RSA isn't just a relic – it's got an educational treasure trove. It's a great example of how the difficulty of prime factorization can be turned into a one-way function.\n\nFirst, we'll take a brief look at how RSA generates keys, encrypts, and decrypts data. Then, we'll explore the math behind it, which will help us grasp why RSA was designed the way it is.\n\n------------------------------------------------------------------------\n\n# Key Generation\n\nRSA key generation involves several steps to generate a public and a private key:\n\n-   **Select two large prime numbers:** First, we pick two prime numbers $p$ and $q$, which should be large enough to ensure the security. Note that $p \\neq q$\n-   **Calculate the modulo:** The modulo is denoted as $n$ and it defines the modulo algebraic structure that we operate on\n\n$$\nn = p \\cdot q\n$$\n\n-   **Evaluate Euler’s Phi (totient) function at $n$:** This is an important step but we will discuss the equation below later as we move forward.\n\n$$\n\\phi (n) =  (p-1) \\cdot (q-1)\n$$\n\n-   **Choose a public exponent:** Choose a public exponent $e$, which should satisfy the following condition ($gcd(x,y)$ stands for greatest common divisor of $x$ and $y$ ):\n\n$$\n1<e<\\phi(n) \\; \\land \\; gcd(e, \\phi(n)) = 1\n$$\n\n-   **Calculate the secret exponent:** Calculate the secret exponent d, such that\n\n$$\ne \\cdot d \\equiv 1 \\; mod \\; \\phi(n)\n$$\n\nPublic key $pk$ is $(n,e)$ and secret key $sk$ is $(n,d)$.\n\n------------------------------------------------------------------------\n\n# Encryption and Decryption\n\nOnce the public and private keys are generated, encryption and decryption is pretty simple:\n\n$$\nEnc(pk, m) := c =  m^e \\; mod \\; n\n$$\n\n$$\nDec(sk, c) = c^d \\; mod \\; n\n$$\n\n------------------------------------------------------------------------\n\nYou might be thinking, \"How does this even work? What's the trick?\" Well, the magic happens behind the scenes with a bunch of number theory, and we're all set to dive right into it!\n\nLet's introduce you to the mathematics that will help us grasp why RSA functions as it does.\n\n------------------------------------------------------------------------\n\n# Euler's Totient (Phi) Function\n\nIn number theory, Euler's totient function counts the positive integers up to a given integer $n$ that are relatively prime to $n$. It is written using the Greek letter phi as $ \\phi $, and may also be called Euler's phi function. In other words, it is the number of integers $k$ in the range $1 \\leq k \\leq n$ for which the greatest common divisor $gcd(n, k)$ is equal to $1$.\n\nTo illustrate, consider this example:\n\n$$ \\displaylines{\\textrm{Let } n=6 \\\\ gcd(0,6) = 6 \\;\\; ,\\;\\; gcd(1,6)=1 \\;\\; ,\\;\\; gcd(2,6) = 2 \\\\ gcd (3,6) = 3 \\;\\; ,\\;\\; gcd(4,6) = 2 \\;\\; ,\\;\\; gcd(5,6) = 1} $$\n\nHere, we see that there are only 2 integers, which are relatively prime to 6:\n\n$$\n\\implies \\phi(n) = \\phi(6) = 2\n$$\n\nBut as you can infer from the example, this isn't the most efficient way to calculate Euler's totient function for a given number $n$. There's actually a simpler approach to compute this function for any integer, thanks to the fact that Euler's totient function is a multiplicative function, which means:\n\n$$\n\\displaylines{\\textrm{Let } n= p \\cdot q \\textrm{  and }p \\textrm{ and } q \\textrm{ are coprime} \\\\  \\phi(n)=\\phi(p \\cdot q) = \\phi(p) \\cdot \\phi(q)}\n$$\n\nMultiplicative property of Euler’s totient function is actually not a trivial property. We can prove this property using Chinese Remainder Theorem (CRT).\n\n## Chinese Remainder Theorem\n\nThe Chinese Remainder Theorem (CRT) is a fundamental theorem in number theory that deals with solving systems of simultaneous modular congruences. It provides a way to find a unique solution to a set of congruences when the moduli involved are pairwise coprime (i.e., they have no common factors other than 1). The theorem is named after its historical association with ancient Chinese mathematics.\n\n**Theorem:**\n\nLet $n_1, n_2, ..., n_k$ be pairwise coprime positive integers and let $a_1,a_2,...,a_k$ be any set of integers. Then the system of modular congruences\n\n$$\n\\displaylines{x \\equiv a_1 \\;(mod \\;n_1)\\\\x \\equiv a_2 \\;(mod \\; n_2)\\\\.\\\\.\\\\x \\equiv \\; a_k \\; (mod \\; n_k) }\n$$\n\nhas a **unique** solution in $mod \\; N$, whereas $N:= n_1 \\cdot n_2 \\cdot...\\cdot n_k$\n\nEssentially, what the thorem states is that, the map\n\n$$\nx \\; mod \\; N \\mapsto (x \\; mod \\; n_1,x \\; mod \\; n_2,...,x \\; mod \\; n_k )\n$$\n\ndefines an isomorphism between $\\mathbb{Z}/N\\mathbb{Z}$ and $\\mathbb{Z}/n_1\\mathbb{Z}\\times\\mathbb{Z}/n_2\\mathbb{Z}\\times...\\times\\mathbb{Z}/n_k\\mathbb{Z}$\n\nI'm not going to delve into a formal proof explaining why Euler's totient function acts as a multiplicative function under certain assumptions. However, what's essential to recognize here is that the isomorphism between these two rings leads to the pivotal observation of Euler's totient function possessing a multiplicative property.\n\nThere's another observation we can make about Euler's totient function, and it will come in handy as we proceed:\n\n------------------------------------------------------------------------\n\nLet $p$ be a prime and $k \\geq1$. Then the following equation holds:\n\n$$\n\\phi(p^k) = p^k - p^{k-1}\n$$\n\n**Proof:** Since $p$ is a prime number, the only possible values of $gcd(p^k, m)$ are $1, p, p^2, ..., p^k$, and the only way to have $gcd(p^k, m) > 1$ is if $m$ is a multiple of $p$, that is, $m \\in {p, 2p, 3p, ..., p^{k − 1} \\cdot p = p^k}$, and there are $p^{k − 1}$ such multiples not greater than $p^k$. Therefore, the other $p^k − p^{k − 1}$ numbers are all relatively prime to $p^k$[²](https://en.wikipedia.org/wiki/Euler%27s_totient_function).\n\n**Example:** Let's compute $\\phi(3^2)$:\n\n$$\n\\displaylines{gcd(0,9) = 9 \\;\\; ,\\;\\; gcd(1,9)=1  \\;\\; ,\\;\\;  gcd(2,9) = 1 \\\\ gcd (3,9) = 3  \\;\\; ,\\;\\;  gcd(4,9) = 1 \\;\\; ,\\;\\; gcd(5,9) = 1 \\\\gcd(6,9) = 3 \\;\\; ,\\;\\; gcd(7,9)=1  \\;\\; ,\\;\\;  gcd(8,9) = 1\\\\ \\implies \\phi(3^2) = 6 = 3^2 - 3^1}\n$$\n\n------------------------------------------------------------------------\n\nNow let's take a look at the simpler approach to compute this function for any integer:\n\n------------------------------------------------------------------------\n\nLet $m$ has the following prime factorization:\n\n$$\nm = p_1^{e_1} \\cdot p_2^{e_2}\\cdot...\\cdot p_n^{e_n}\n$$\n\nwhereas $e_i \\in \\mathbb{N}$. With a little assistance from our previous observation, we can assert the following:\n\n$$\n\\phi(m) = \\prod_{i=1}^n\\phi(p_i^{e^i}) = \\prod_{i=1}^n(p_i^{e_i} - p_i^{e_i -1})\n$$\n\n------------------------------------------------------------------------\n\nNow it should be more clear how we computed $\\phi(n)$ as $\\phi(n) = \\phi(p) \\cdot \\phi(q)$ in the key generation section.\n\nPrime factorization of $n$ is $n = p^1 \\cdot q^1$, then:\n\n$$\n\\phi(n) = \\phi(p^1 \\cdot q^1) = \\phi(p^1) \\cdot \\phi(q^1) = (p^1-p^0)\\cdot(q^1-q^0) = (p-1)\\cdot(q-1)\n$$\n\nThis insight should shed light on why we generate prime numbers to generate keys in the first place. It's crucial to emphasize that this computation becomes feasible only when we possess the prime factorization of a given integer $n$. Yet, for a large $n$, it might prove impractical to factorize it into its prime components within a reasonable timeframe. Exactly for this reason, we emphasize that **\"RSA uses the complexity of prime factorization to guarantee its security,\"** as this very characteristic forms the heart of the RSA cryptosystem.\n\nIf we're aware of the prime factors of a specific number $n$, we can efficiently calculate the Euler's totient function $\\phi(n)$, allowing for efficient decryption. However, when we lack knowledge of the prime factors of $n$ efficiently computing $\\phi(n)$ becomes a daunting task. We could resort to a brute-force approach, yet this becomes unfeasible when dealing with significantly large values of $n$, because of the immense time it would demand.\n\n------------------------------------------------------------------------\n\nNow that we've understood some key features of Euler's totient function that are vital for key generation, let's address the question: **\"Why do we even use Euler's totient function?\"**\n\nLet's explore the answer.\n\n# Euler's Theorem\n\nEuler's Theorem is integral to the security and functioning of RSA encryption. The use of modular exponentiation in both encryption and decryption operations leverages Euler's Theorem. Here's how:\n\n------------------------------------------------------------------------\n\n**Euler's Theorem:**\n\nLet $a$ and $m$ be positive coprime integers ($gcd(a,m)=1$), then:\n\n$$\na^{\\phi(m)} \\equiv 1 \\; (mod \\; m)\n$$\n\n**Example:**\n\nLet $m =10$ and $a=3$.\n\nSince $gcd(10,3) = 1$, $a^{\\phi(m)}$ should be equivalent to $1 \\; (mod \\; m)$. Let's check:\n\n$$\n\\phi(m) = \\phi(10) = \\phi(5 \\cdot 2) = (5-1) \\cdot (2-1) = 4\n$$\n\n$$\na^{\\phi(m)} = 3^4 =81 \\equiv 1 \\; (mod \\; 10)\n$$\n\n------------------------------------------------------------------------\n\nUnfortunately, I'm not a mathematician. :/ So, I don't want to explain a proof, which I'm not really familiar with. Let's just accept Euler's theorem as a given truth, which, in fact, it is :D\n\nLet's now look at a special case of Euler's Theorem, which is Fermat's Little Theorem !\n\n------------------------------------------------------------------------\n\n**Fermat's Little Theorem:**\n\nLet $a$ be a positive integer, $p$ be a prime and $gcd(a,p) = 1$. Then:\n\n$$\na^p \\equiv a \\; (mod \\; p)\n$$\n\n$$\n\\iff\n$$\n\n$$\na \\cdot (a^{p-1} -1) \\equiv 0 \\; (mod \\; p)\n$$\n\n$$\n\\iff\n$$\n\n$$\na^{p-1} \\equiv 1 \\; (mod \\; p)\n$$\n\n**Proof**: Fermat's Little Theorem is basically a special case of Euler's theorem, if the modulo is a prime number.\n\nLet $a$ be a positive integer, $p$ be a prime and $gcd(a,p) = 1$.\n\nSince $gcd(a,p)=1$, using Euler's Theorem:\n\n$$\na^{\\phi(p)} \\equiv 1 \\; (mod \\; p)\n$$\n\nWe know that $\\phi(p) = p-1$, if $p$ is a prime.\n\n$$\n\\implies a^{p-1} \\equiv 1 \\; (mod \\; p)\n$$\n\n------------------------------------------------------------------------\n\n# Correctness of RSA\n\nNow, armed with all the necessary tools, we can demonstrate that the $Enc(pk,m)$ and $Dec(sk,c)$ operations within the RSA cryptosystem act as perfect inverses of one another.\n\n------------------------------------------------------------------------\n\n**Lemma(Correctness):** A public key algorithm $(Gen,Enc,Dec)$ is correct if\n\n$$\n\\forall m,pk,sk: (pk,sk) \\leftarrow Gen(1^k) \\implies Dec(sk, Enc(pk,m)) = m\n$$\n\n------------------------------------------------------------------------\n\n**Let's prove the correctness of RSA together, step by step !**\n\nLet $pk=(n,e)$ and $sk=(n,d)$ be a pair of public and secret key generated by RSA key generation algorithm.\n\nSince $Dec(sk, Enc(pk,m)) = (m^e)^d \\; mod \\; n$, what we want to show is, that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; n)\n$$\n\nFirst thing to note here is, that it is enough to check that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; p)\n$$\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; q)\n$$\n\nBecause by the Chinese Remainder Theorem, the map\n\n$$\nm \\; mod \\; n \\mapsto (m \\; mod \\; p,m \\; mod \\; q)\n$$\n\ndefines a ring isomorphism between $\\mathbb{Z}/n\\mathbb{Z}$ and $\\mathbb{Z}/p\\mathbb{Z}\\times\\mathbb{Z}/q\\mathbb{Z}$.\n\nSince $p$ and $q$ are arbitrarily chosen two prime numbers, they don't have variable specific constraints and hence it is enough to prove that\n\n$$\n(m^e)^d \\equiv m \\; (mod \\; p)\n$$\n\nThen proof of $(m^e)^d \\equiv m \\; (mod \\; q)$ would be analogue.\n\n$$\n(m^e)^d \\equiv m^{e \\cdot d} \\; (mod \\; p) \\tag{1}\n$$\n\n$$\nm^{e \\cdot d} \\equiv m^{(1 \\; mod \\; \\phi(n))} \\; (mod \\; p) \\tag{2}\n$$\n\n$$\nm^{(1 \\; mod \\; \\phi(n))} \\equiv m^{(k \\cdot \\phi(n) + 1)} \\; (mod \\; p), \\; k \\in \\mathbb{N}_0 \\tag{3}\n$$\n\n$$\nm^{(k \\cdot \\phi(n) + 1)} \\equiv m^{k \\cdot \\phi(n)} \\cdot m \\; (mod \\; p) \\tag{4}\n$$\n\n$$\nm^{k \\cdot \\phi(n)} \\cdot m \\equiv m^{k \\cdot (p-1) \\cdot (q-1)} \\cdot m \\; (mod \\; p) \\tag{5}\n$$\n\n$$\nm^{k \\cdot (p-1) \\cdot (q-1)} \\cdot m \\equiv (m^{p-1})^{k \\cdot (q-1)} \\cdot m \\; (mod \\; p) \\tag{6}\n$$\n\n$$\n(m^{p-1})^{k \\cdot (q-1)} \\cdot m \\equiv 1^{k \\cdot (q-1)} \\cdot m \\; (mod \\; p)\\tag{7}\n$$\n\n$$\n 1^{k \\cdot (q-1)} \\cdot m \\equiv m \\; (mod \\; p) \\tag{8}\n$$\n\n-   Step $(2)$ holds true because in our key generation, we intentionally selected $d$ to serve as the inverse of $e$ in modulo $\\phi(n)$.\n\n-   Step $(5)$ holds true because of properties of Euler's totient function mentioned above. If you can't understand why this step holds true, check the section about Euler's totient function and do not forget that $n = p \\cdot q$ and $p,q$ are prime numbers with $p \\neq q$\n\n-   Step $(7)$ holds true because of Fermat's Little Theorem\n\n------------------------------------------------------------------------"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":["cosmo","brand"],"title-block-banner":true,"title":"Understanding RSA: Number Theory,Primes, Fermat, Euler and such","author":"Rodi Düger","date":"2023-08-28","categories":["computer_science"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}